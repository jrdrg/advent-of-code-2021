// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var Caml = require("rescript/lib/js/caml.js");
var Grid = require("./grid.bs.js");
var List = require("rescript/lib/js/list.js");
var $$Array = require("rescript/lib/js/array.js");
var Caml_array = require("rescript/lib/js/caml_array.js");
var Caml_format = require("rescript/lib/js/caml_format.js");
var Belt_SetString = require("rescript/lib/js/belt_SetString.js");
var Caml_exceptions = require("rescript/lib/js/caml_exceptions.js");

var inputStr = "target area: x=32..65, y=-225..-177";

function parseInput(input) {
  var InvalidInput = /* @__PURE__ */Caml_exceptions.create("InvalidInput");
  var match = input.match(/target area: x=(\d+)\.\.(\d+), y=(-?\d+)\.\.(-?\d+)/);
  var match$1;
  if (match !== null) {
    if (match.length !== 5) {
      throw {
            RE_EXN_ID: InvalidInput,
            _1: input,
            Error: new Error()
          };
    }
    var x1 = match[1];
    var x2 = match[2];
    var y1 = match[3];
    var y2 = match[4];
    var c = $$Array.map(Caml_format.caml_int_of_string, [
          x1,
          x2,
          y1,
          y2
        ]);
    match$1 = [
      [
        Caml_array.get(c, 0),
        Caml_array.get(c, 2)
      ],
      [
        Caml_array.get(c, 1),
        Caml_array.get(c, 3)
      ]
    ];
  } else {
    throw {
          RE_EXN_ID: InvalidInput,
          _1: input,
          Error: new Error()
        };
  }
  var match$2 = match$1[1];
  var match$3 = match$1[0];
  return Grid.fromPointsList(true, {
              hd: [
                match$3[1],
                match$3[0]
              ],
              tl: {
                hd: [
                  match$2[1],
                  match$2[0]
                ],
                tl: /* [] */0
              }
            });
}

function hasPassedTargetArea(pos, velocity, targetArea) {
  var match = Grid.boundaries(targetArea);
  if (velocity[0] < 0 && pos[0] < match[0][0]) {
    return true;
  } else {
    return pos[1] > match[1][1];
  }
}

function canNeverHitTargetArea(param, param$1, targetArea) {
  if (param$1[1] !== 0) {
    return false;
  }
  var c = param[1];
  var match = Grid.boundaries(targetArea);
  if (c < match[0][1]) {
    return true;
  } else {
    return c > match[1][1];
  }
}

function processStep(pos, velocity) {
  var vx = velocity[1];
  var vy = velocity[0];
  var nextPoint_0 = pos[0] + vy | 0;
  var nextPoint_1 = pos[1] + vx | 0;
  var nextPoint = [
    nextPoint_0,
    nextPoint_1
  ];
  var vx$p = vx > 0 ? vx - 1 | 0 : (
      vx < 0 ? vx + 1 | 0 : vx
    );
  var vy$p = vy - 1 | 0;
  return [
          nextPoint,
          [
            vy$p,
            vx$p
          ]
        ];
}

function checkIfHitTargetArea(param, targetArea) {
  var _pos = [
    0,
    0
  ];
  var _velocity = [
    param[1],
    param[0]
  ];
  var _points = /* [] */0;
  while(true) {
    var points = _points;
    var velocity = _velocity;
    var pos = _pos;
    var match = processStep(pos, velocity);
    var nextVelocity = match[1];
    var nextPoint = match[0];
    if (Grid.isWithinBoundaries(nextPoint, targetArea)) {
      return {
              TAG: /* Hit */0,
              _0: velocity,
              _1: $$Array.of_list(List.rev({
                        hd: nextPoint,
                        tl: points
                      }))
            };
    }
    if (canNeverHitTargetArea(nextPoint, nextVelocity, targetArea)) {
      var match$1 = Grid.distance(nextPoint, targetArea);
      return {
              TAG: /* CanNeverHit */1,
              _0: match$1[0],
              _1: match$1[1]
            };
    }
    if (hasPassedTargetArea(nextPoint, nextVelocity, targetArea)) {
      var match$2 = Grid.distance(nextPoint, targetArea);
      return {
              TAG: /* PassedTargetArea */2,
              _0: match$2[0],
              _1: match$2[1]
            };
    }
    _points = {
      hd: nextPoint,
      tl: points
    };
    _velocity = nextVelocity;
    _pos = nextPoint;
    continue ;
  };
}

function opposite(num) {
  if (num < 0) {
    return 1;
  } else if (num > 0) {
    return -1;
  } else {
    return 0;
  }
}

function findHighestYPosition(_velocities, _highest, targetArea) {
  while(true) {
    var highest = _highest;
    var velocities = _velocities;
    if (!velocities) {
      return highest;
    }
    var rest = velocities.tl;
    var velocity = velocities.hd;
    var match = checkIfHitTargetArea(velocity, targetArea);
    switch (match.TAG | 0) {
      case /* Hit */0 :
          var maxY = $$Array.fold_left((function (mY, param) {
                  return Caml.caml_int_max(mY, param[0]);
                }), 0, match._1);
          var newHighest = highest !== undefined && maxY <= highest[0] ? highest : [
              maxY,
              velocity
            ];
          _highest = newHighest;
          _velocities = rest;
          continue ;
      case /* CanNeverHit */1 :
      case /* PassedTargetArea */2 :
          _velocities = rest;
          continue ;
      
    }
  };
}

function part1(param) {
  var input = parseInput(inputStr);
  var match = Grid.size(input);
  var m = Math.imul(Caml.caml_int_max(match[0], match[1]), 10);
  var possibleVelocities = List.flatten($$Array.to_list($$Array.init(m, (function (r) {
                  return $$Array.to_list($$Array.init(m, (function (c) {
                                    return [
                                            r,
                                            c
                                          ];
                                  })));
                }))));
  return findHighestYPosition(possibleVelocities, undefined, input);
}

console.log("Part 1", part1(undefined));

function getHitList(_velocities, _hits, targetArea) {
  while(true) {
    var hits = _hits;
    var velocities = _velocities;
    if (!velocities) {
      return hits;
    }
    var rest = velocities.tl;
    var velocity = velocities.hd;
    var match = checkIfHitTargetArea(velocity, targetArea);
    switch (match.TAG | 0) {
      case /* Hit */0 :
          _hits = {
            hd: velocity,
            tl: hits
          };
          _velocities = rest;
          continue ;
      case /* CanNeverHit */1 :
      case /* PassedTargetArea */2 :
          _velocities = rest;
          continue ;
      
    }
  };
}

function part2(param) {
  var input = parseInput(inputStr);
  var match = Grid.size(input);
  var m = Math.imul(Caml.caml_int_max(match[0], match[1]), 10);
  var possibleVelocities = List.flatten($$Array.to_list($$Array.init(m, (function (r) {
                  return $$Array.to_list($$Array.init(m, (function (c) {
                                    return [
                                            r,
                                            c
                                          ];
                                  })));
                }))));
  var negativeVelocities = $$Array.map((function (param) {
          return [
                  param[0],
                  Math.imul(-1, param[1])
                ];
        }), $$Array.of_list(possibleVelocities));
  var possibleVelocities$1 = $$Array.to_list($$Array.append($$Array.of_list(possibleVelocities), negativeVelocities));
  var hits = getHitList(possibleVelocities$1, /* [] */0, input);
  return Belt_SetString.size(Belt_SetString.fromArray($$Array.of_list(List.map((function (param) {
                            return String(param[0]) + "," + String(param[1]);
                          }), hits))));
}

console.log("Part 2", part2(undefined));

var exampleInputStr = "target area: x=20..30, y=-10..-5";

exports.exampleInputStr = exampleInputStr;
exports.inputStr = inputStr;
exports.parseInput = parseInput;
exports.hasPassedTargetArea = hasPassedTargetArea;
exports.canNeverHitTargetArea = canNeverHitTargetArea;
exports.processStep = processStep;
exports.checkIfHitTargetArea = checkIfHitTargetArea;
exports.opposite = opposite;
exports.findHighestYPosition = findHighestYPosition;
exports.part1 = part1;
exports.getHitList = getHitList;
exports.part2 = part2;
/*  Not a pure module */
