// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var List = require("rescript/lib/js/list.js");
var $$Array = require("rescript/lib/js/array.js");
var Caml_array = require("rescript/lib/js/caml_array.js");
var Caml_format = require("rescript/lib/js/caml_format.js");
var Caml_exceptions = require("rescript/lib/js/caml_exceptions.js");

var operatorCountExampleStr = "EE00D40C823060";

var InvalidHexDigit = /* @__PURE__ */Caml_exceptions.create("Day16.Binary.InvalidHexDigit");

function fromHex(hex) {
  switch (hex) {
    case "0" :
        return "0000";
    case "1" :
        return "0001";
    case "2" :
        return "0010";
    case "3" :
        return "0011";
    case "4" :
        return "0100";
    case "5" :
        return "0101";
    case "6" :
        return "0110";
    case "7" :
        return "0111";
    case "8" :
        return "1000";
    case "9" :
        return "1001";
    case "A" :
        return "1010";
    case "B" :
        return "1011";
    case "C" :
        return "1100";
    case "D" :
        return "1101";
    case "E" :
        return "1110";
    case "F" :
        return "1111";
    default:
      throw {
            RE_EXN_ID: InvalidHexDigit,
            _1: hex,
            Error: new Error()
          };
  }
}

function stringToNumber(binaryString) {
  return $$Array.map(Caml_format.caml_int_of_string, binaryString.split(""));
}

function toDecimal(binary) {
  var l = binary.length;
  return $$Array.fold_left((function (dec, param) {
                var value = Math.pow(2, param[0]) * param[1];
                return dec + value;
              }), 0, $$Array.mapi((function (i, digit) {
                    return [
                            (l - i | 0) - 1 | 0,
                            digit
                          ];
                  }), binary));
}

var Binary = {
  InvalidHexDigit: InvalidHexDigit,
  fromHex: fromHex,
  stringToNumber: stringToNumber,
  toDecimal: toDecimal
};

function pVersion(packet) {
  return packet.version.toString();
}

function packetTypeToString(packetType) {
  if (packetType.TAG === /* Literal */0) {
    return "Literal " + packetType._0.toString();
  }
  var subpackets = $$Array.of_list(List.map(packetToString, packetType._1)).join(",");
  return "Operator " + String(packetType._0) + " [" + subpackets + "]";
}

function packetToString(packet) {
  return "<v(" + packet.version.toString() + "):" + packetTypeToString(packet.packetType) + ">";
}

function parseInput(input) {
  return stringToNumber($$Array.map(fromHex, input.split("")).join(""));
}

function a2s(arr) {
  return arr.join("");
}

function parseLiteralValue(_binary, _value, _length) {
  while(true) {
    var length = _length;
    var value = _value;
    var binary = _binary;
    var InvalidLiteralValue = /* @__PURE__ */Caml_exceptions.create("InvalidLiteralValue");
    if (binary) {
      var match = binary.hd;
      if (match !== 0) {
        if (match === 1) {
          var match$1 = binary.tl;
          if (match$1) {
            var match$2 = match$1.tl;
            if (match$2) {
              var match$3 = match$2.tl;
              if (match$3) {
                var match$4 = match$3.tl;
                if (match$4) {
                  var val = value + $$Array.map((function (prim) {
                            return String(prim);
                          }), [
                          match$1.hd,
                          match$2.hd,
                          match$3.hd,
                          match$4.hd
                        ]).join("");
                  _length = length + 5 | 0;
                  _value = val;
                  _binary = match$4.tl;
                  continue ;
                }
                
              }
              
            }
            
          }
          
        }
        
      } else {
        var match$5 = binary.tl;
        if (match$5) {
          var match$6 = match$5.tl;
          if (match$6) {
            var match$7 = match$6.tl;
            if (match$7) {
              var match$8 = match$7.tl;
              if (match$8) {
                var val$1 = value + $$Array.map((function (prim) {
                          return String(prim);
                        }), [
                        match$5.hd,
                        match$6.hd,
                        match$7.hd,
                        match$8.hd
                      ]).join("");
                return [
                        toDecimal(stringToNumber(val$1)),
                        length + 5 | 0
                      ];
              }
              
            }
            
          }
          
        }
        
      }
    }
    throw {
          RE_EXN_ID: InvalidLiteralValue,
          _1: $$Array.of_list(binary).join(""),
          Error: new Error()
        };
  };
}

function lengthTypeIdToString(typeId) {
  if (typeId.TAG === /* TotalLength */0) {
    return "TotalLength(" + String(typeId._0) + ")";
  } else {
    return "SubpacketsCount(" + String(typeId._0) + ")";
  }
}

function determineOperatorType(binary) {
  var InvalidLengthTypeId = /* @__PURE__ */Caml_exceptions.create("InvalidLengthTypeId");
  var match = Caml_array.get(binary, 0);
  if (match !== 0) {
    if (match !== 1) {
      throw {
            RE_EXN_ID: InvalidLengthTypeId,
            _1: binary.join(""),
            Error: new Error()
          };
    }
    var subPacketCount = toDecimal($$Array.sub(binary, 1, 11));
    return [
            {
              TAG: /* SubpacketsCount */1,
              _0: subPacketCount | 0
            },
            12
          ];
  }
  var totalLength = toDecimal($$Array.sub(binary, 1, 15));
  return [
          {
            TAG: /* TotalLength */0,
            _0: totalLength | 0
          },
          16
        ];
}

function splitPacket(binary) {
  var version = toDecimal($$Array.sub(binary, 0, 3));
  var typeId = toDecimal($$Array.sub(binary, 3, 3));
  var value = $$Array.sub(binary, 6, binary.length - 6 | 0);
  return [
          version,
          typeId,
          value
        ];
}

function packetsToString(packets) {
  return $$Array.of_list(List.map(packetToString, packets));
}

function decodeSubpacketsByLength(_binary, _subpackets, _currentLength, totalLength) {
  while(true) {
    var currentLength = _currentLength;
    var subpackets = _subpackets;
    var binary = _binary;
    console.log("decoding subpackets by length", [
          currentLength,
          totalLength,
          binary.length
        ]);
    if (currentLength >= totalLength) {
      console.log(" -- COMPLETED READING length", $$Array.of_list(List.map(packetToString, subpackets)));
      console.log(" ?? sanity check", [
            binary.length,
            currentLength
          ]);
      return subpackets;
    }
    var subArray = $$Array.sub(binary, currentLength, binary.length - currentLength | 0);
    console.log(" -- length", subArray.length);
    var match = splitPacket(subArray);
    var match$1 = decodePacket(subArray);
    var length = match$1[1];
    var subpacket = match$1[0];
    console.log(" -- subpacket split", [
          match[0],
          match[1],
          match[2].join(""),
          length
        ]);
    console.log(" -- subpacket", packetToString(subpacket));
    _currentLength = currentLength + length | 0;
    _subpackets = {
      hd: subpacket,
      tl: subpackets
    };
    _binary = subArray;
    continue ;
  };
}

function decodeSubpacketsByCount(_binary, _subpackets, _currentCount, totalCount, _arrayPos) {
  while(true) {
    var arrayPos = _arrayPos;
    var currentCount = _currentCount;
    var subpackets = _subpackets;
    var binary = _binary;
    console.log("decoding subpackets by count", [
          currentCount,
          totalCount,
          binary.length
        ]);
    if (currentCount >= totalCount) {
      console.log(" -- COMPLETED READING count", [
            $$Array.of_list(List.map(packetToString, subpackets)),
            arrayPos
          ]);
      return [
              subpackets,
              arrayPos
            ];
    }
    var match = decodePacket(binary);
    var length = match[1];
    var subpacket = match[0];
    console.log(" > decoded by count", [
          packetToString(subpacket),
          length
        ]);
    var newLength = binary.length - length | 0;
    var subArray = $$Array.sub(binary, length, newLength);
    console.log(" >> new length", [
          length,
          newLength
        ]);
    console.log(" >> new length", [
          length,
          newLength,
          binary.length,
          subArray.length
        ]);
    _arrayPos = length;
    _currentCount = currentCount + 1 | 0;
    _subpackets = {
      hd: subpacket,
      tl: subpackets
    };
    _binary = subArray;
    continue ;
  };
}

function decodePacket(binary) {
  var match = splitPacket(binary);
  var value = match[2];
  var typeId = match[1];
  var version = match[0];
  console.log("\n\n -- Decoding packet, length", binary.length);
  console.log(" -- contents", binary.join(""));
  if (typeId !== 4) {
    var match$1 = determineOperatorType(value);
    var packetStart = match$1[1];
    var operatorType = match$1[0];
    var packetValues = $$Array.sub(value, packetStart, value.length - packetStart | 0);
    console.log("operator", [
          version,
          typeId,
          lengthTypeIdToString(operatorType)
        ]);
    console.log("pv", [
          packetValues.join(""),
          packetValues.length
        ]);
    var match$2;
    if (operatorType.TAG === /* TotalLength */0) {
      var length = operatorType._0;
      console.log(" +++ Operator, length", length);
      var sub = $$Array.sub(packetValues, 0, length);
      var s = decodeSubpacketsByLength(sub, /* [] */0, 0, length);
      var diff = packetValues.length - length | 0;
      console.log(" === diff", [
            diff,
            packetValues.length,
            length
          ]);
      match$2 = [
        s,
        (length + 6 | 0) + packetStart | 0
      ];
    } else {
      var count = operatorType._0;
      console.log(" +++ Operator, count", count);
      var match$3 = decodeSubpacketsByCount(packetValues, /* [] */0, 0, count, 0);
      var subpacketsLength = match$3[1];
      var diff$1 = value.length - subpacketsLength | 0;
      console.log(" === l", [
            subpacketsLength,
            diff$1,
            (subpacketsLength + 6 | 0) + packetStart | 0
          ]);
      match$2 = [
        match$3[0],
        (subpacketsLength + 6 | 0) + packetStart | 0
      ];
    }
    return [
            {
              version: version,
              packetType: {
                TAG: /* Operator */1,
                _0: typeId | 0,
                _1: List.rev(match$2[0])
              }
            },
            match$2[1]
          ];
  }
  var match$4 = parseLiteralValue($$Array.to_list(value), "", 0);
  var length$1 = match$4[1];
  var literalValue = match$4[0];
  console.log(" +++ Literal", [
        literalValue,
        length$1
      ]);
  return [
          {
            version: version,
            packetType: {
              TAG: /* Literal */0,
              _0: literalValue
            }
          },
          length$1 + 6 | 0
        ];
}

function versionSum(_packets, _sum) {
  while(true) {
    var sum = _sum;
    var packets = _packets;
    if (!packets) {
      return sum;
    }
    var match = packets.hd;
    var match$1 = match.packetType;
    var version = match.version;
    if (match$1.TAG === /* Literal */0) {
      _sum = sum + version;
      _packets = packets.tl;
      continue ;
    }
    var remainingPackets = List.append(match$1._1, packets.tl);
    _sum = sum + version;
    _packets = remainingPackets;
    continue ;
  };
}

function part1(param) {
  parseInput(operatorCountExampleStr);
  var input = parseInput("C0015000016115A2E0802F182340");
  $$Array.map(Caml_format.caml_int_of_string, "1100000000000001010100000000000000000001011000010001010110100010111000001000000000101111000110000010001101000000".split(""));
  var match = decodePacket(input);
  var decoded = match[0];
  console.log("input", input.join(""));
  console.log("decoded", decoded);
  console.log("Decoded", packetToString(decoded));
  console.log("Length", match[1]);
  console.log("Sum", versionSum({
            hd: decoded,
            tl: /* [] */0
          }, 0));
  return decoded;
}

console.log("Part 1", part1(undefined));

var shortExampleStr = "D2FE28";

var operatorExampleStr = "38006F45291200";

exports.shortExampleStr = shortExampleStr;
exports.operatorExampleStr = operatorExampleStr;
exports.operatorCountExampleStr = operatorCountExampleStr;
exports.Binary = Binary;
exports.pVersion = pVersion;
exports.packetTypeToString = packetTypeToString;
exports.packetToString = packetToString;
exports.parseInput = parseInput;
exports.a2s = a2s;
exports.parseLiteralValue = parseLiteralValue;
exports.lengthTypeIdToString = lengthTypeIdToString;
exports.determineOperatorType = determineOperatorType;
exports.splitPacket = splitPacket;
exports.packetsToString = packetsToString;
exports.decodeSubpacketsByLength = decodeSubpacketsByLength;
exports.decodeSubpacketsByCount = decodeSubpacketsByCount;
exports.decodePacket = decodePacket;
exports.versionSum = versionSum;
exports.part1 = part1;
/*  Not a pure module */
